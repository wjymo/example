用户a注册（注册时为其生成二维码，存在fastdfs），登录，登录后可以上传头像，上传到fastdfs，
修改昵称（注册时还有修改昵称时，要获取到昵称的拼音首字母并持久化，在通讯录时会使用），
在发现页面可以搜索其它用户（比如b），搜索到的话进入b的详情页，此页面有两个按钮，一个取消按钮，一个可以发起好友申请，
发起好友申请后，会在friend_request表中生成一条记录，申请人是a，接受人是b。
此时b的首页会通过b的id查询friend_request表（匹配接收人id），就会显示a请求添加自己为好友，可以选择拒绝或同意，
拒绝的话直接删除friend_request表中对应记录即可，同意的话，也删除friend_request表中对应记录，然后还要在friends表中生成两条记录，分别是a对应b，和b对应a。
在a的通讯录中，会通过a的id在friends表中查出a的所有好友，并且通过首字母分组排序。
然后选择一个用户的话就会进入和他的聊天页面（来到这个页面同时也会把被选中的朋友的信息带来，id，昵称，头像等），此页面前端有两个方法，一个发送消息，一个接受消息，
点发送消息时，会将消息封装起来发送到服务端，包括消息内容，自己的id，朋友的id以及此操作的类型，
服务端接受到此消息对象后，先将消息对象录入mysql，然后通过朋友id找到对应的channel，向其推送此消息内容，
在客户端的websocket的onmessage方法中接收到此消息，可拿到发送者的id，进而拿到其对应的页面，因为对应接收者而言，发送者id对应的页面就是他俩聊天的页面，
（这是移动端上的搞法，在pc端，直接在onmessage方法中调用receiveMsg方法渲染即可）
调用接收消息的方法，将消息内容渲染到页面上



前端项目在启动时，会初始化websocket，在onopen时，向服务端发送一条消息，消息中包含了当前用户的id和此消息类型（建立userId和channel的关联关系），
服务端接收到userId，将其和当前channel关联在一个map中。
发往netty服务端的消息是被分为了4种，上述初始化时是一种，还有聊天发送消息时为一种，
还有签收消息的消息（这是因为接收聊天消息的客户端未必正打开着页面，这样如果不做持久化消息就会丢失，做了持久化了，那么消息就必然要分状态），
在前端websocket的onmessage方法被调用时（即netty服务端主动向前端发送消息时），代表着接收到了聊天消息，此时就可以做签收